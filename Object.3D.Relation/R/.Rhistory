Detecte3DRelation <- function (TableFrom, TableTo, ClosedFrom, ClosedTo ) {
#### TableFrom is Check Against List, with 6 column, with column names:
#### c ("MIN.X","MAX.X", "")
#### ClosedFrom is a vector, c(T,T) for example
TableTo$RNO <- seq.int(nrow(TableTo))
# INCLUDED Interval method
## X-axis
### From is Check Against List
TableFrom.X <- as.matrix(select(TableFrom,MIN.X,MAX.X))
### convert to intervals and name each row
From.X <- intervals::Intervals_full(TableFrom.X, closed = ClosedFrom, type = "R")
rownames(From.X) <- TableFrom$RNO
### To is Checking List
TableTo.X <- as.matrix(select(TableTo,MIN.X,MAX.X))
To.X <- intervals::Intervals_full(TableTo.X,closed = ClosedTo, type = "R")
### Result List of X included
list.X <- intervals::interval_included(From.X, To.X)
df.list.X <- plyr::ldply(list.X, as.data.frame)
colnames(df.list.X) <- c("WithinRNO","TableToRNO")
df.list.X <- as_tibble(df.list.X)
## Y-axis
### From is Check Against List
TableFrom.Y <- as.matrix(select(TableFrom,MIN.Y,MAX.Y))
### convert to intervals and name each row
From.Y <- intervals::Intervals_full(TableFrom.Y, closed = ClosedFrom, type = "R")
rownames(From.Y) <- TableFrom$RNO
### To is Checking List
TableTo.Y <- as.matrix(select(TableTo,MIN.Y,MAX.Y))
To.Y <- intervals::Intervals_full(TableTo.Y,closed = ClosedTo, type = "R")
### Result List of Y included
list.Y <- intervals::interval_included(From.Y, To.Y)
df.list.Y <- plyr::ldply(list.Y, as.data.frame)
colnames(df.list.Y) <- c("WithinRNO","TableToRNO")
df.list.Y <- tibble::as_tibble(df.list.Y)
## Z-axis
### From is Check Against List
TableFrom.Z <- as.matrix(select(TableFrom,MIN.Z,MAX.Z))
From.Z <- intervals::Intervals_full(TableFrom.Z, closed = ClosedFrom, type = "R")
rownames(From.Z) <- TableFrom$RNO
### To is Checking List
TableTo.Z <-  as.matrix(select(TableTo,MIN.Z,MAX.Z))
To.Z <- intervals::Intervals_full(TableTo.Z,closed = ClosedTo, type = "R")
### Result List of Z included
list.Z <- intervals::interval_included(From.Z, To.Z)
df.list.Z <- plyr::ldply(list.Z, as.data.frame)
colnames(df.list.Z) <- c("WithinRNO","TableToRNO")
df.list.Z <- tibble::as_tibble(df.list.Z)
## Bind the all result table of XYZ, then filter for count = 3
df.list.XYZ <- dplyr::bind_rows(df.list.X,df.list.Y,df.list.Z)
df.list.XYZ <- dplyr::group_by(df.list.XYZ, TableToRNO, WithinRNO)
df.list.XYZ <- dplyr::summarise(df.list.XYZ, n=n())
df.list.XYZ <- dplyr::filter(df.list.XYZ, n >2)
Within <- df.list.XYZ %>%
dplyr::group_by(TableToRNO,WithinRNO)  %>%
dplyr::summarise(n=n()) %>%
dplyr::filter(n >2)
return(Within)
# OVERLAP Interval method
TableTo.rest <- TableTo %>% dplyr::filter(!RNO %in% Within$TableToRNO)
TableTo.rest$RRNO <- seq(1:nrow(TableTo.rest))
## X-axis
### To is the rest of the checkList
TableTo.rest.X <- select(TableTo.rest,MIN.X,MAX.X)
To.rest.X <- intervals::Intervals(TableTo.rest.X,closed = ClosedTo, type = "R")
### List of X overlapped
list.rest.X <- intervals::interval_overlap(From.X, To.rest.X)
df.list.rest.X <- plyr::ldply(list.rest.X, as.data.frame)
colnames(df.list.rest.X) <- c("OverlapRNO","TableToRRNO")
df.list.rest.X <- as_tibble(df.list.rest.X)
## Y-axis
### To is the rest of the checkList
TableTo.rest.Y <- select(TableTo.rest,MIN.Y,MAX.Y)
To.rest.Y <- intervals::Intervals(TableTo.rest.Y,closed = ClosedTo, type = "R")
#### List of Y overlapped
list.rest.Y <- intervals::interval_overlap(From.Y, To.rest.Y)
df.list.rest.Y <- plyr::ldply(list.rest.Y, as.data.frame)
colnames(df.list.rest.Y) <- c("OverlapRNO","TableToRRNO")
df.list.rest.Y <- as_tibble(df.list.rest.Y)
## Z-axis
### To is the rest of the checkList
TableTo.rest.Z <- select(TableTo.rest,MIN.Z,MAX.Z)
To.rest.Z <- intervals::Intervals(TableTo.rest.Z,closed = ClosedTo, type = "R")
### List of Z overlapped
list.rest.Z <- intervals::interval_overlap(From.Z, To.rest.Z)
df.list.rest.Z <- plyr::ldply(list.rest.Z, as.data.frame)
colnames(df.list.rest.Z) <- c("OverlapRNO","TableToRRNO")
df.list.rest.Z <- as_tibble(df.list.rest.Z)
### Bind the rows of the result table of XYZ, then filter for count = 3
df.list.rest.XYZ <-  bind_rows(df.list.rest.X,df.list.rest.Y,df.list.rest.Z)
Overlap <- df.list.rest.XYZ %>%
group_by(TableToRRNO,OverlapRNO) %>%
summarise(n=n()) %>%
filter(n >2)
## Combine overlap and included results
Within.Result <- left_join(TableTo, Within,by = c("RNO" = "TableToRNO") )
Overlap.R <- left_join(TableTo.rest, Overlap,by = c("RRNO" = "TableToRRNO") ) %>%
select(8:11)
Overlap.Result <- left_join(TableTo,Overlap.R, by = "RNO" )
Result <- left_join(Within.Result, Overlap.Result, by = c("MIN.X", "MAX.X", "MIN.Y", "MAX.Y", "MIN.Z", "MAX.Z", "Manual", "RNO"))
return(Result)
}
## Read tables
Check.Against <- "~/PHD/PCL/Automation S Curve/3D detection/CheckAgainst.csv"
AgainstList <- read.csv(Check.Against)
### add row number for table
AgainstList$RNO <- seq.int(nrow(AgainstList))
Check.List <- "~/PHD/PCL/Automation S Curve/3D detection/CheckList.csv"
CheckList <- read.csv(Check.List)
Detecte3DRelation(AgainstList,CheckList,c(T,T),c(T,T))
Detecte3DRelation <- function (TableFrom, TableTo, ClosedFrom, ClosedTo ) {
#### TableFrom is Check Against List, with 6 column, with column names:
#### c ("MIN.X","MAX.X", "")
#### ClosedFrom is a vector, c(T,T) for example
TableTo$RNO <- seq.int(nrow(TableTo))
# INCLUDED Interval method
## X-axis
### From is Check Against List
TableFrom.X <- as.matrix(dplyr::select(TableFrom,MIN.X,MAX.X))
### convert to intervals and name each row
From.X <- intervals::Intervals_full(TableFrom.X, closed = ClosedFrom, type = "R")
rownames(From.X) <- TableFrom$RNO
### To is Checking List
TableTo.X <- as.matrix(dplyr::select(TableTo,MIN.X,MAX.X))
To.X <- intervals::Intervals_full(TableTo.X,closed = ClosedTo, type = "R")
### Result List of X included
list.X <- intervals::interval_included(From.X, To.X)
df.list.X <- plyr::ldply(list.X, as.data.frame)
colnames(df.list.X) <- c("WithinRNO","TableToRNO")
df.list.X <- as_tibble(df.list.X)
## Y-axis
### From is Check Against List
TableFrom.Y <- as.matrix(dplyr::select(TableFrom,MIN.Y,MAX.Y))
### convert to intervals and name each row
From.Y <- intervals::Intervals_full(TableFrom.Y, closed = ClosedFrom, type = "R")
rownames(From.Y) <- TableFrom$RNO
### To is Checking List
TableTo.Y <- as.matrix(dplyr::select(TableTo,MIN.Y,MAX.Y))
To.Y <- intervals::Intervals_full(TableTo.Y,closed = ClosedTo, type = "R")
### Result List of Y included
list.Y <- intervals::interval_included(From.Y, To.Y)
df.list.Y <- plyr::ldply(list.Y, as.data.frame)
colnames(df.list.Y) <- c("WithinRNO","TableToRNO")
df.list.Y <- tibble::as_tibble(df.list.Y)
## Z-axis
### From is Check Against List
TableFrom.Z <- as.matrix(dplyr::select(TableFrom,MIN.Z,MAX.Z))
From.Z <- intervals::Intervals_full(TableFrom.Z, closed = ClosedFrom, type = "R")
rownames(From.Z) <- TableFrom$RNO
### To is Checking List
TableTo.Z <-  as.matrix(dplyr::select(TableTo,MIN.Z,MAX.Z))
To.Z <- intervals::Intervals_full(TableTo.Z,closed = ClosedTo, type = "R")
### Result List of Z included
list.Z <- intervals::interval_included(From.Z, To.Z)
df.list.Z <- plyr::ldply(list.Z, as.data.frame)
colnames(df.list.Z) <- c("WithinRNO","TableToRNO")
df.list.Z <- tibble::as_tibble(df.list.Z)
## Bind the all result table of XYZ, then filter for count = 3
df.list.XYZ <- dplyr::bind_rows(df.list.X,df.list.Y,df.list.Z)
df.list.XYZ <- dplyr::group_by(df.list.XYZ, TableToRNO, WithinRNO)
df.list.XYZ <- dplyr::summarise(df.list.XYZ, n=n())
df.list.XYZ <- dplyr::filter(df.list.XYZ, n >2)
Within <- df.list.XYZ %>%
dplyr::group_by(TableToRNO,WithinRNO)  %>%
dplyr::summarise(n=n()) %>%
dplyr::filter(n >2)
return(Within)
# OVERLAP Interval method
TableTo.rest <- TableTo %>% dplyr::filter(!RNO %in% Within$TableToRNO)
TableTo.rest$RRNO <- seq(1:nrow(TableTo.rest))
## X-axis
### To is the rest of the checkList
TableTo.rest.X <- select(TableTo.rest,MIN.X,MAX.X)
To.rest.X <- intervals::Intervals(TableTo.rest.X,closed = ClosedTo, type = "R")
### List of X overlapped
list.rest.X <- intervals::interval_overlap(From.X, To.rest.X)
df.list.rest.X <- plyr::ldply(list.rest.X, as.data.frame)
colnames(df.list.rest.X) <- c("OverlapRNO","TableToRRNO")
df.list.rest.X <- as_tibble(df.list.rest.X)
## Y-axis
### To is the rest of the checkList
TableTo.rest.Y <- select(TableTo.rest,MIN.Y,MAX.Y)
To.rest.Y <- intervals::Intervals(TableTo.rest.Y,closed = ClosedTo, type = "R")
#### List of Y overlapped
list.rest.Y <- intervals::interval_overlap(From.Y, To.rest.Y)
df.list.rest.Y <- plyr::ldply(list.rest.Y, as.data.frame)
colnames(df.list.rest.Y) <- c("OverlapRNO","TableToRRNO")
df.list.rest.Y <- as_tibble(df.list.rest.Y)
## Z-axis
### To is the rest of the checkList
TableTo.rest.Z <- select(TableTo.rest,MIN.Z,MAX.Z)
To.rest.Z <- intervals::Intervals(TableTo.rest.Z,closed = ClosedTo, type = "R")
### List of Z overlapped
list.rest.Z <- intervals::interval_overlap(From.Z, To.rest.Z)
df.list.rest.Z <- plyr::ldply(list.rest.Z, as.data.frame)
colnames(df.list.rest.Z) <- c("OverlapRNO","TableToRRNO")
df.list.rest.Z <- as_tibble(df.list.rest.Z)
### Bind the rows of the result table of XYZ, then filter for count = 3
df.list.rest.XYZ <-  bind_rows(df.list.rest.X,df.list.rest.Y,df.list.rest.Z)
Overlap <- df.list.rest.XYZ %>%
group_by(TableToRRNO,OverlapRNO) %>%
summarise(n=n()) %>%
filter(n >2)
## Combine overlap and included results
Within.Result <- left_join(TableTo, Within,by = c("RNO" = "TableToRNO") )
Overlap.R <- left_join(TableTo.rest, Overlap,by = c("RRNO" = "TableToRRNO") ) %>%
select(8:11)
Overlap.Result <- left_join(TableTo,Overlap.R, by = "RNO" )
Result <- left_join(Within.Result, Overlap.Result, by = c("MIN.X", "MAX.X", "MIN.Y", "MAX.Y", "MIN.Z", "MAX.Z", "Manual", "RNO"))
return(Result)
}
Detecte3DRelation(AgainstList,CheckList,c(T,T),c(T,T))
Detecte3DRelation <- function (TableFrom, TableTo, ClosedFrom, ClosedTo ) {
#### TableFrom is Check Against List, with 6 column, with column names:
#### c ("MIN.X","MAX.X", "")
#### ClosedFrom is a vector, c(T,T) for example
TableTo$RNO <- seq.int(nrow(TableTo))
# INCLUDED Interval method
## X-axis
### From is Check Against List
TableFrom.X <- as.matrix(dplyr::select(TableFrom,MIN.X,MAX.X))
### convert to intervals and name each row
From.X <- intervals::Intervals_full(TableFrom.X, closed = ClosedFrom, type = "R")
rownames(From.X) <- TableFrom$RNO
### To is Checking List
TableTo.X <- as.matrix(dplyr::select(TableTo,MIN.X,MAX.X))
To.X <- intervals::Intervals_full(TableTo.X,closed = ClosedTo, type = "R")
### Result List of X included
list.X <- intervals::interval_included(From.X, To.X)
df.list.X <- plyr::ldply(list.X, as.data.frame)
colnames(df.list.X) <- c("WithinRNO","TableToRNO")
df.list.X <- tibble::as_tibble(df.list.X)
## Y-axis
### From is Check Against List
TableFrom.Y <- as.matrix(dplyr::select(TableFrom,MIN.Y,MAX.Y))
### convert to intervals and name each row
From.Y <- intervals::Intervals_full(TableFrom.Y, closed = ClosedFrom, type = "R")
rownames(From.Y) <- TableFrom$RNO
### To is Checking List
TableTo.Y <- as.matrix(dplyr::select(TableTo,MIN.Y,MAX.Y))
To.Y <- intervals::Intervals_full(TableTo.Y,closed = ClosedTo, type = "R")
### Result List of Y included
list.Y <- intervals::interval_included(From.Y, To.Y)
df.list.Y <- plyr::ldply(list.Y, as.data.frame)
colnames(df.list.Y) <- c("WithinRNO","TableToRNO")
df.list.Y <- tibble::as_tibble(df.list.Y)
## Z-axis
### From is Check Against List
TableFrom.Z <- as.matrix(dplyr::select(TableFrom,MIN.Z,MAX.Z))
From.Z <- intervals::Intervals_full(TableFrom.Z, closed = ClosedFrom, type = "R")
rownames(From.Z) <- TableFrom$RNO
### To is Checking List
TableTo.Z <-  as.matrix(dplyr::select(TableTo,MIN.Z,MAX.Z))
To.Z <- intervals::Intervals_full(TableTo.Z,closed = ClosedTo, type = "R")
### Result List of Z included
list.Z <- intervals::interval_included(From.Z, To.Z)
df.list.Z <- plyr::ldply(list.Z, as.data.frame)
colnames(df.list.Z) <- c("WithinRNO","TableToRNO")
df.list.Z <- tibble::as_tibble(df.list.Z)
## Bind the all result table of XYZ, then filter for count = 3
df.list.XYZ <- dplyr::bind_rows(df.list.X,df.list.Y,df.list.Z)
df.list.XYZ <- dplyr::group_by(df.list.XYZ, TableToRNO, WithinRNO)
df.list.XYZ <- dplyr::summarise(df.list.XYZ, n=n())
df.list.XYZ <- dplyr::filter(df.list.XYZ, n >2)
Within <- df.list.XYZ %>%
dplyr::group_by(TableToRNO,WithinRNO)  %>%
dplyr::summarise(n=n()) %>%
dplyr::filter(n >2)
return(Within)
# OVERLAP Interval method
TableTo.rest <- TableTo %>% dplyr::filter(!RNO %in% Within$TableToRNO)
TableTo.rest$RRNO <- seq(1:nrow(TableTo.rest))
## X-axis
### To is the rest of the checkList
TableTo.rest.X <- select(TableTo.rest,MIN.X,MAX.X)
To.rest.X <- intervals::Intervals(TableTo.rest.X,closed = ClosedTo, type = "R")
### List of X overlapped
list.rest.X <- intervals::interval_overlap(From.X, To.rest.X)
df.list.rest.X <- plyr::ldply(list.rest.X, as.data.frame)
colnames(df.list.rest.X) <- c("OverlapRNO","TableToRRNO")
df.list.rest.X <- as_tibble(df.list.rest.X)
## Y-axis
### To is the rest of the checkList
TableTo.rest.Y <- select(TableTo.rest,MIN.Y,MAX.Y)
To.rest.Y <- intervals::Intervals(TableTo.rest.Y,closed = ClosedTo, type = "R")
#### List of Y overlapped
list.rest.Y <- intervals::interval_overlap(From.Y, To.rest.Y)
df.list.rest.Y <- plyr::ldply(list.rest.Y, as.data.frame)
colnames(df.list.rest.Y) <- c("OverlapRNO","TableToRRNO")
df.list.rest.Y <- as_tibble(df.list.rest.Y)
## Z-axis
### To is the rest of the checkList
TableTo.rest.Z <- select(TableTo.rest,MIN.Z,MAX.Z)
To.rest.Z <- intervals::Intervals(TableTo.rest.Z,closed = ClosedTo, type = "R")
### List of Z overlapped
list.rest.Z <- intervals::interval_overlap(From.Z, To.rest.Z)
df.list.rest.Z <- plyr::ldply(list.rest.Z, as.data.frame)
colnames(df.list.rest.Z) <- c("OverlapRNO","TableToRRNO")
df.list.rest.Z <- as_tibble(df.list.rest.Z)
### Bind the rows of the result table of XYZ, then filter for count = 3
df.list.rest.XYZ <-  bind_rows(df.list.rest.X,df.list.rest.Y,df.list.rest.Z)
Overlap <- df.list.rest.XYZ %>%
group_by(TableToRRNO,OverlapRNO) %>%
summarise(n=n()) %>%
filter(n >2)
## Combine overlap and included results
Within.Result <- left_join(TableTo, Within,by = c("RNO" = "TableToRNO") )
Overlap.R <- left_join(TableTo.rest, Overlap,by = c("RRNO" = "TableToRRNO") ) %>%
select(8:11)
Overlap.Result <- left_join(TableTo,Overlap.R, by = "RNO" )
Result <- left_join(Within.Result, Overlap.Result, by = c("MIN.X", "MAX.X", "MIN.Y", "MAX.Y", "MIN.Z", "MAX.Z", "Manual", "RNO"))
return(Result)
}
Detecte3DRelation(AgainstList,CheckList,c(T,T),c(T,T))
Detecte3DRelation <- function (TableFrom, TableTo, ClosedFrom, ClosedTo ) {
#### TableFrom is Check Against List, with 6 column, with column names:
#### c ("MIN.X","MAX.X", "")
#### ClosedFrom is a vector, c(T,T) for example
TableTo$RNO <- seq.int(nrow(TableTo))
# INCLUDED Interval method
## X-axis
### From is Check Against List
TableFrom.X <- as.matrix(dplyr::select(TableFrom,MIN.X,MAX.X))
### convert to intervals and name each row
From.X <- intervals::Intervals_full(TableFrom.X, closed = ClosedFrom, type = "R")
rownames(From.X) <- TableFrom$RNO
### To is Checking List
TableTo.X <- as.matrix(dplyr::select(TableTo,MIN.X,MAX.X))
To.X <- intervals::Intervals_full(TableTo.X,closed = ClosedTo, type = "R")
### Result List of X included
list.X <- intervals::interval_included(From.X, To.X)
df.list.X <- plyr::ldply(list.X, as.data.frame)
colnames(df.list.X) <- c("WithinRNO","TableToRNO")
df.list.X <- tibble::as_tibble(df.list.X)
## Y-axis
### From is Check Against List
TableFrom.Y <- as.matrix(dplyr::select(TableFrom,MIN.Y,MAX.Y))
### convert to intervals and name each row
From.Y <- intervals::Intervals_full(TableFrom.Y, closed = ClosedFrom, type = "R")
rownames(From.Y) <- TableFrom$RNO
### To is Checking List
TableTo.Y <- as.matrix(dplyr::select(TableTo,MIN.Y,MAX.Y))
To.Y <- intervals::Intervals_full(TableTo.Y,closed = ClosedTo, type = "R")
### Result List of Y included
list.Y <- intervals::interval_included(From.Y, To.Y)
df.list.Y <- plyr::ldply(list.Y, as.data.frame)
colnames(df.list.Y) <- c("WithinRNO","TableToRNO")
df.list.Y <- tibble::as_tibble(df.list.Y)
## Z-axis
### From is Check Against List
TableFrom.Z <- as.matrix(dplyr::select(TableFrom,MIN.Z,MAX.Z))
From.Z <- intervals::Intervals_full(TableFrom.Z, closed = ClosedFrom, type = "R")
rownames(From.Z) <- TableFrom$RNO
### To is Checking List
TableTo.Z <-  as.matrix(dplyr::select(TableTo,MIN.Z,MAX.Z))
To.Z <- intervals::Intervals_full(TableTo.Z,closed = ClosedTo, type = "R")
### Result List of Z included
list.Z <- intervals::interval_included(From.Z, To.Z)
df.list.Z <- plyr::ldply(list.Z, as.data.frame)
colnames(df.list.Z) <- c("WithinRNO","TableToRNO")
df.list.Z <- tibble::as_tibble(df.list.Z)
## Bind the all result table of XYZ, then filter for count = 3
df.list.XYZ <- dplyr::bind_rows(df.list.X,df.list.Y,df.list.Z)
df.list.XYZ <- dplyr::group_by(df.list.XYZ, TableToRNO, WithinRNO)
df.list.XYZ <- dplyr::summarise(df.list.XYZ, n=n())
Within <- dplyr::filter(df.list.XYZ, n >2)
return(Within)
# OVERLAP Interval method
TableTo.rest <- TableTo %>% dplyr::filter(!RNO %in% Within$TableToRNO)
TableTo.rest$RRNO <- seq(1:nrow(TableTo.rest))
## X-axis
### To is the rest of the checkList
TableTo.rest.X <- select(TableTo.rest,MIN.X,MAX.X)
To.rest.X <- intervals::Intervals(TableTo.rest.X,closed = ClosedTo, type = "R")
### List of X overlapped
list.rest.X <- intervals::interval_overlap(From.X, To.rest.X)
df.list.rest.X <- plyr::ldply(list.rest.X, as.data.frame)
colnames(df.list.rest.X) <- c("OverlapRNO","TableToRRNO")
df.list.rest.X <- as_tibble(df.list.rest.X)
## Y-axis
### To is the rest of the checkList
TableTo.rest.Y <- select(TableTo.rest,MIN.Y,MAX.Y)
To.rest.Y <- intervals::Intervals(TableTo.rest.Y,closed = ClosedTo, type = "R")
#### List of Y overlapped
list.rest.Y <- intervals::interval_overlap(From.Y, To.rest.Y)
df.list.rest.Y <- plyr::ldply(list.rest.Y, as.data.frame)
colnames(df.list.rest.Y) <- c("OverlapRNO","TableToRRNO")
df.list.rest.Y <- as_tibble(df.list.rest.Y)
## Z-axis
### To is the rest of the checkList
TableTo.rest.Z <- select(TableTo.rest,MIN.Z,MAX.Z)
To.rest.Z <- intervals::Intervals(TableTo.rest.Z,closed = ClosedTo, type = "R")
### List of Z overlapped
list.rest.Z <- intervals::interval_overlap(From.Z, To.rest.Z)
df.list.rest.Z <- plyr::ldply(list.rest.Z, as.data.frame)
colnames(df.list.rest.Z) <- c("OverlapRNO","TableToRRNO")
df.list.rest.Z <- as_tibble(df.list.rest.Z)
### Bind the rows of the result table of XYZ, then filter for count = 3
df.list.rest.XYZ <-  bind_rows(df.list.rest.X,df.list.rest.Y,df.list.rest.Z)
Overlap <- df.list.rest.XYZ %>%
group_by(TableToRRNO,OverlapRNO) %>%
summarise(n=n()) %>%
filter(n >2)
## Combine overlap and included results
Within.Result <- left_join(TableTo, Within,by = c("RNO" = "TableToRNO") )
Overlap.R <- left_join(TableTo.rest, Overlap,by = c("RRNO" = "TableToRRNO") ) %>%
select(8:11)
Overlap.Result <- left_join(TableTo,Overlap.R, by = "RNO" )
Result <- left_join(Within.Result, Overlap.Result, by = c("MIN.X", "MAX.X", "MIN.Y", "MAX.Y", "MIN.Z", "MAX.Z", "Manual", "RNO"))
return(Result)
}
Detecte3DRelation(AgainstList,CheckList,c(T,T),c(T,T))
devtools::document()
library(tidyverse)
library(intervals)
library(plyr)
# Read tables ------------------------------------------------------------
## Read tables
Check.Against <- "~/PHD/PCL/Automation S Curve/3D detection/CheckAgainst.csv"
AgainstList <- read.csv(Check.Against)
### add row number for table
AgainstList$RNO <- seq.int(nrow(AgainstList))
Check.List <- "~/PHD/PCL/Automation S Curve/3D detection/CheckList.csv"
CheckList <- read.csv(Check.List)
### add row number for table
CheckList$RNO <- seq.int(nrow(CheckList))
### X-axis
#### From is Check Against List
AgainstList.X <- as.matrix(select(AgainstList,MIN.X,MAX.X))
#### convert to intervals and name each row
From.X <- Intervals_full(AgainstList.X, closed = c(F,F), type = "R")
rownames(From.X) <- AgainstList$RNO
head(From.X)
#### To is Checking List
CheckList.X <- as.matrix(select(CheckList,MIN.X,MAX.X))
To.X <- Intervals_full(CheckList.X,closed = c(F,F), type = "R")
head(To.X)
#### Result List of X included
interval_included(From.X, To.X)
list.X <- interval_included(From.X, To.X)
# df.list.X <- data.frame(as.list(list.X))
#
df.list.X <- ldply(list.X, as.data.frame)
colnames(df.list.X) <- c("WithinRNO","CheckListRNO")
head(df.list.X)
df.list.X <- as_tibble(df.list.X)
### Y-axis
#### From is Check Against List
AgainstList.Y <- as.matrix(select(AgainstList,MIN.Y,MAX.Y))
#### convert to intervals and name each row
From.Y <- Intervals_full(AgainstList.Y, closed = c(T,T), type = "R")
rownames(From.Y) <- AgainstList$RNO
head(From.Y)
#### To is Checking List
CheckList.Y <- as.matrix(select(CheckList,MIN.Y,MAX.Y))
To.Y <- Intervals_full(CheckList.Y,closed = c(T,T), type = "R")
head(To.Y)
#### Result List of Y included
interval_included(From.Y, To.Y)
list.Y <- interval_included(From.Y, To.Y)
# df.list.Y <- as.data.frame(list.Y)
df.list.Y <- ldply(list.Y, as.data.frame)
colnames(df.list.Y) <- c("WithinRNO","CheckListRNO")
head(df.list.Y)
df.list.Y <- as_tibble(df.list.Y)
### Z-axis
#### From is Check Against List
AgainstList.Z <- as.matrix(select(AgainstList,MIN.Z,MAX.Z))
From.Z <- Intervals_full(AgainstList.Z, closed = c(T,T), type = "R")
rownames(From.Z) <- AgainstList$RNO
head(From.Z)
#### To is Checking List
CheckList.Z <-  as.matrix(select(CheckList,MIN.Z,MAX.Z))
To.Z <- Intervals_full(CheckList.Z,closed = c(T,T), type = "R")
head(To.Z)
#### Result List of Z included
interval_included(From.Z, To.Z, check_valid = TRUE)
list.Z <- interval_included(From.Z, To.Z)
#
# df.list.Z <- as.data.frame(list.Z)
df.list.Z <- ldply(list.Z, as.data.frame)
colnames(df.list.Z) <- c("WithinRNO","CheckListRNO")
head(df.list.Z)
df.list.Z <- as_tibble(df.list.Z)
### Bind the rows of the result table of XYZ, then filter for count = 3
df.list.XYZ <-  bind_rows(df.list.X,df.list.Y,df.list.Z)
detach("package:plyr", unload=TRUE)
Within <- df.list.XYZ %>%
group_by(CheckListRNO,WithinRNO) %>%
summarise(n=n()) %>%
filter(n >2)
CheckList %>% dplyr::filter(!RNO %in% Within$CheckListRNO)
dplyr::filter(CheckList, !RNO %in% Within$CheckListRNO)
devtools::document()
devtools::document()
devtools::load_all()
devtools::load_all()
## Read tables
Check.Against <- "~/PHD/PCL/Automation S Curve/3D detection/CheckAgainst.csv"
AgainstList <- read.csv(Check.Against)
### add row number for table
AgainstList$RNO <- seq.int(nrow(AgainstList))
Check.List <- "~/PHD/PCL/Automation S Curve/3D detection/CheckList.csv"
CheckList <- read.csv(Check.List)
Detecte3DRelation(AgainstList,CheckList,c(T,T),c(T,T))
